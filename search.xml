<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[构建F8-App Appendix-3:在windows平台使用React Native 开发]]></title>
      <url>%2F2016%2F06%2F20%2F%E6%9E%84%E5%BB%BAF8-App-Appendix-3-%E5%B0%86f8%E7%A7%BB%E6%A4%8D%E5%88%B0windows%E5%B9%B3%E5%8F%B0-%E4%BD%BF%E7%94%A8React-Native-%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[大家可能已经了解到，微软正努力将 React Native 引入到 windows 通用应用平台。对于 React Native 开发者来说，这是一个可以让自己的应用到达 2.7 亿 windows 10 用户（包括手机、电脑、xbox 甚至是 hololens VR眼镜）的绝佳机会。基于同 facebook 的合作以及将 React Native 引入到 windows 所要作出的努力，我们在 windows 应用商店发布了 F8 开发者大会应用。 所有代码的移植基于最近开源的 F8 github 代码库。 下面这个视频演示了在UWP( windows 通用应用平台)上运行的 F8 应用中源自 React Native 的部分特性：https://www.youtube.com/watch?v=51_M9Dp5X80&amp;feature=youtu.be (国内用户需翻墙才能查看) 将 F8 应用移植到 windows 平台占用了一个 3 人小组 80/100 的时间，历时 3 周完成。我们将此数据完全透明的公布给大家，主要是基于这样的考虑：决策是否使用 React Native 这样的技术来进行开发，开发效率是一个很重要的参考指标。 虽然我们揭开了 React Native 在 windows 平台开发的序幕，但当前 React Native 的部分核心视图管理器和原生模块在 windows 上仍不可用， React Native 的第三方依赖库也都还不支持 windows 平台。具体就这个应用来说，缺少针对菜单和过滤器的 SplitView 视图管理器；缺少切换 tab 和会话页的FlipView视图管理器; 在滚动视图管理器里面，缺少合适的运行事件用来处理拖拽和内容视图更新。我们也缺少一个剪贴板模块-用来拷贝粘贴 wifi 的详情；缺少用作导航状态存储的异步存储模块；缺少用作登出和其他警告处理的对话框模块；也缺少一个用来处理应用的信息tab页中的链接行为的启动器模块。对于第三方模块，我们缺少线性渐变视图管理器、facebook sdk 模块、 React Native 分享模块。其中一部分，例如启动器模块，花了我们小半天时间搞定。其他更复杂的模块，比如 facebook sdk 模块，花了我们超过 1 天的时间；这里主要的工作量在于找到恰当的原生 api 依赖，然后实现功能并且测试。 当我们将要把应用发布到应用商店时，发现有一些细节还没有考虑到：发布到商店的应用必须使用 .net 原生环境编译。我们运气不错，很快搞定了这件事。因为其中只有很少的一部分 api 是 .net 原生环境所不支持的（主要是关于反射方面的）；我们只需要解决这部分反射相关的问题。 我们对应用作了一些设计和风格上的调整以让它在 windows phone 上看起来更棒。这里我不会给出太多的细节，因为 facebook 已经详细的阐述了如何用 React Native 为 android 和iOS 作平台定制开发, 而这些定制开发的原则也同样适用于 windows 平台。剔除内核适配、第三方组件适配开发以及发布到应用商店这些工作量，通过 js 语言实现的 windows 平台定制开发和风格调整仅花了 1 名开发者不到 1 周的时间。请大家留意这个工作量估计，因为在可期待的未来—当 React Native 在 Windows 平台上的成熟度接近 iOS 和 android 的时候，这就是 React Native 应用移植到 windows 时开发者的唯一工作量。下面我给出了一些例子来展现如何让 windows 应用变得不同（与 iOS 和 android 应用相比）。 F8 ListContainer 组件的平台特定风格设置代码:12345678910111213141516171819202122var styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: 'white', &#125;, listView: &#123; ios: &#123; backgroundColor: 'transparent', &#125;, android: &#123; backgroundColor: 'white', &#125;, windows: &#123; backgroundColor: 'white', &#125; &#125;, headerTitle: &#123; color: 'white', fontWeight: 'bold', fontSize: 20, &#125;,&#125;); F8TabsView.window.js 中： 12345678910111213141516171819class F8TabsView extends React.Component &#123; ... render() &#123; return ( &lt;F8SplitView ref="splitView" paneWidth=&#123;290&#125; panePosition="left" renderPaneView=&#123;this.renderPaneView&#125;&gt; &lt;View style=&#123;styles.content&#125; key=&#123;this.props.tab&#125;&gt; &#123;this.renderContent()&#125; &lt;/View&gt; &lt;/F8SplitView&gt; ); &#125; ...&#125; 对比 F8TabsView.android.js： 12345678910111213141516171819class F8TabsView extends React.Component &#123; ... render() &#123; return ( &lt;F8DrawerLayout ref="drawer" drawerWidth=&#123;290&#125; drawerPosition="left" renderNavigationView=&#123;this.renderNavigationView&#125;&gt; &lt;View style=&#123;styles.content&#125; key=&#123;this.props.tab&#125;&gt; &#123;this.renderContent()&#125; &lt;/View&gt; &lt;/F8DrawerLayout&gt; ); &#125; ...&#125; 对比 F8TabsView.ios.js： 12345678910111213141516class F8TabsView extends React.Component &#123; ... render() &#123; return ( &lt;TabBarIOS tintColor=&#123;F8Colors.darkText&#125;&gt; &lt;TabBarItemIOS&gt; ... &lt;/TabBarItemIOS&gt; ... &lt;/TabBarIOS&gt; ); &#125; ...&#125; React Native 的理念是做一个“水平的平台“，意思是更倾向于”learn once, write anywhere”，以区别于 java 的”write once, run everywhere”。虽然我们的 F8 windows 应用体验接近于 Android，但如果有更多的开发时间，我们很可能会修改其界面和菜单让它看起来更像是一个 windows 应用。例如在 XAML 中，SplitView 支持一种紧凑的显示模式，其 panel 关闭时该视图仅从一个下拉菜单里显示所有的 icon 图片。对应用的桌面版本和 continuum 特性来说，这个体验很棒。同时，在 XAML 中 pivot 被广泛用于翻页，拥有 pivot 风格的页面和会话标题对 windows 用户来说将会是更熟悉的体验。 总的来说，我们基于 React Native 将 F8 开发者大会应用移植到 windows 的过程让人感觉很好； React Native 应用移植到 windows 平台也将会变得越来越容易。我们希望我们所作出的努力可以证明在 windows 平台上用 React Native 开发绝不仅仅是实验性质的。通过社区的强大支持，它可能为你的 React Native 应用带来更广泛的受众（来自 windows 平台的用户）；这是一个属于 React Native 开发者的绝好机会。 在 5 月 13 日爱尔兰都柏林举行的 DECODED Conference 上，我们将继续讨论此次移植的经验以及其他一些关于在 windows 上使用 React Native 的议题。此外，这里有一篇文章，分享了另一个微软的团队在 UWP 平台上使用 CodePush 实现 React Native 代码热更新的经验。特别感谢 Matt Podwysocki 和 Eero Bragge ，是他们的努力工作才得以让 F8 windows 应用如期到来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建F8-App Appendix-2:使用Relay和GraphQL]]></title>
      <url>%2F2016%2F06%2F18%2F%E6%9E%84%E5%BB%BAF8-App-Appendix-2-%E4%BD%BF%E7%94%A8Relay%E5%92%8CGraphQL%2F</url>
      <content type="text"><![CDATA[在我们最初构建 app 时，我们讨论了对数据层的选择。并将我们最终使用的 Redux 框架与 Facebook 的开源框架 Relay 进行了对比。 当时我们选择了 Redux，是因为与 Relay 相比，Redux 提供了更便捷的数据层实现，且与 Parse 的数据存储可以更快更容易的结合使用。 F8 的 iOS 和 Android 的应用开发完成上线后。我们再次回顾对数据层的框架选择，想尝试在我们的 App 中如何使用 Relay。 缓慢的转变在传统原生 App 的开发中，更换数据层意味着整个应用的推翻重写，已有的功能都会被全部替换。 React Native 则不同。替换一个独立的 View 的数据层时，已有的绝大部份数据设置逻辑（Redux, Parse, 和相关的绑定），我们都可以保留。不需要重写或大量重构，我们可以只把 App 中的某个模块的数据层替换为新的数据层，其余模块继续使用已有数据层。 需要说明的是，这种逐步改善 App 的能力可以极大的降低维护和升级的开销，对应用的开发非常有利。 那么相比 Redux，使用 Relay 和 GraphQL 如果处理数据层呢？ 介绍 Relay 和 GraphQL首先，简单的说，Relay 是 app 中的一个数据框架。GraphQL 是 Relay 中表示数据模型的查询语言。GraphQL 运行在服务器上，与 app 相隔离，给 Relay 提供交互所需要的数据源(我们之后的教程中会介绍 GraphQL 服务器的搭建，敬请期待)。 Relay 不是 Flux 构架的衍生物，且只能和 GraphQL 配合使用。这就直接意味着和 Redux 模型完全彻底不同。我们在数据层教程中已经介绍的 Store/Reducer/Component 交互在 Relay 中是不存在的。它采用一种不一样的方法，并且移除了你和数据交互时需要做的一些构建工作。 在 Relay 中，各个 React component 具体依赖样的数据，取决于 GraphQL 的使用。Relay 处理一切有关数据获取，当数据改变后更新组件，客户端的数据缓存的事情。当客户端需要修改数据的时候，创建一个 GraphQL Mutation 而不是像使用 Redux 时创建一个 Action. F8 App 中的一个的例子鉴于具有逐渐改变 React Native 应用的一小部分的能力，我们选择把 F8 app 的 Info View 这个模块中的 Redux 替换为 Relay,作为一种概念证明. Info 这个模块在 app 中和其余模块几乎时彻底分离的，而且大量内容都是非交互性的，用这个模块是最佳选择。 Info View 中包含一个非常简单的 &lt;InfoList&gt; 组件：12345678910111213141516171819/* from js/tabs/info/F8InfoView.js */function InfoList(&#123;viewer: &#123;config, faqs, pages&#125;, ...props&#125;) &#123; return ( &lt;PureListView renderEmptyList=&#123;() =&gt; ( &lt;View&gt; &lt;WiFiDetails network=&#123;config.wifiNetwork&#125; password=&#123;config.wifiPassword&#125; /&gt; &lt;CommonQuestions faqs=&#123;faqs&#125; /&gt; &lt;LinksList title="Facebook pages" links=&#123;pages&#125; /&gt; &lt;LinksList title="Facebook policies" links=&#123;POLICIES_LINKS&#125; /&gt; &lt;/View&gt; )&#125; &#123;...props&#125; /&gt; );&#125; 这只是包含一些简单信息展示类组件的基本布局，但组件中的 props 和参数从哪来的呢？哈哈，在这个 js 文件中，我们有一个连接 GraphQL 的 fragment： 12345678910111213141516171819202122/* from js/tabs/info/F8InfoView.js */InfoList = Relay.createContainer(InfoList, &#123; fragments: &#123; viewer: () =&gt; Relay.QL` fragment on User &#123; config &#123; wifiNetwork wifiPassword &#125; faqs &#123; question answer &#125; pages &#123; title url logo &#125; &#125; `, &#125;,&#125;); 这里，我们用一个 GraphSQL fragment 定义了 &lt;InfoList&gt; 组件需要展示的数据。它和我们在 GraphQL 服务器上定义的 GraphQL 对象是对应的： 12345678910111213141516171819202122232425/* from server/schema/schema.js */var F8UserType = new GraphQLObjectType(&#123; name: 'User', description: 'A person who uses our app', fields: () =&gt; (&#123; id: globalIdField('User'), name: &#123; type: GraphQLString, &#125;, ... faqs: &#123; type: new GraphQLList(F8FAQType), resolve: () =&gt; new Parse.Query(FAQ).find(), &#125;, pages: &#123; type: new GraphQLList(F8PageType), resolve: () =&gt; new Parse.Query(Page).find(), &#125;, config: &#123; type: F8ConfigType, resolve: () =&gt; Parse.Config.get(), &#125; &#125;), ...&#125;); 你可以看到数据是如何从 GraphQL 服务器上被获取的，然后 Relay 开始接手所有需要的且在 fragment 中指定的数据。这时 viewer 的参数就可以被 &lt;InfoList&gt; 组件访问到了，使用了一些 destructuring assignments，反过来构建了在组件中使用的 config， faq，pages 变量。 归功于 Relay 的内建逻辑，我们不用担心数据变化的监听，或者数据本地储存等等。我们只需要告诉 Relay 组件中应该有什么数据，然后以标准的 React 方式来设计我们需要的组件。如果 GraphQL 服务器已经搭建好，以上就是我们需要做的所有事情。 我们的 Info View 中没有数据的变化，然而如果你想了解更多原理，请阅读在 Relay 在 mutations 上面的文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建F8-App Appendix-1:本地运行App]]></title>
      <url>%2F2016%2F06%2F15%2F%E6%9E%84%E5%BB%BAF8-App-Appendix-1-%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8CApp%2F</url>
      <content type="text"><![CDATA[当你从苹果商店或者谷歌 Play 上下载了 F8 App，并可以在移动设备上运行它以后，阅读这些教程的同时你也会希望在本地运行 App 玩一玩。 这篇简短的文章，将指导你如何在 OSX 本地搭建和运行源代码（安卓版 React Native 可以支持在 Windows 和 Linux 运行）。 ##要求 在开始之前，你需要安装一些必要的东西： React Native (根据 iOS 和 Android 的引导说明) CocoaPods 1.0+ (仅 iOS) MongoDB (需要在本地运行 Parse Server) ##搭建 ####1. 克隆仓库12$ git clone https://github.com/fbsamples/f8app.git$ cd f8app ####2. 安装依赖（npm v3+）12$ npm install$ (cd ios; pod install) # only for iOS version ####3. 确认 MongoDB 运行正常1$ lsof -iTCP:27017 -sTCP:LISTEN 或者使用外部 MongoDB 服务，设置 DATABASE_URI 1$ export DATABASE_URI=mongodb://example-mongo-hosting.com:1337/my-awesome-database ####4. 启动 Parse/GraphQL 服务1$ npm start ####5. 导入样本数据（本地的 Parse 服务已经运行）1$ npm run import-data 访问以下地址确认一切正常运行： Parse Dashboard: http://localhost:8080/dashboard GraphiQL: http://localhost:8080/graphql ####6. 运行 Android 版 App123$ react-native run-android$ adb reverse tcp:8081 tcp:8081 # required to ensure the Android app can$ adb reverse tcp:8080 tcp:8080 # access the Packager and GraphQL server ####7. 运行 iOS 版 App1$ react-native run-ios]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建F8-App part4]]></title>
      <url>%2F2016%2F06%2F14%2F%E6%9E%84%E5%BB%BAF8-App-part4%2F</url>
      <content type="text"><![CDATA[在传统软件开发生命周期里，测试环节通常往往仅仅是作为一个临近开发结束时才开始进行的特殊环节。由于新推出开源框架发布时往往并未有任何相关测试技术支持，当使用这些框架进行开发时，这种说法便更接近事实真相。 幸运的是， Facebook 在 React Native 构建之初很早的就考虑到了测试策略。在这部分我们将介绍编码阶段如何使用 Nuclide , Flow , 以及 Jest 改善 React Native 代码质量。 Flow : 利用类型检查避免编写糟糕代码Flow为JavaScript 提供以渐进方式工作的静态类型检查，允许我们将 Flow 特性逐步添加到代码中。这是个非常有用的设计。当我们仅仅想为部分代码引入类型检查时， 我们不必为兼容 Flow 而去重写整个 app 。 我们决定从一开始就完全采用 Flow 来配合 React Native 搭建 F8app，在一切必要的地方添加类型注解(type annotations ) ，让 Flow 能在整个代码开发过程中一直尽情发挥力量。 下面我们以曾经在数据教程部分曾提及的一个简单 action 作为示例：12345678910111213/* from js/actions/login.js *//* * @flow */...function skipLogin(): Action &#123; return &#123; type: 'SKIPPED_LOGIN', &#125;;&#125; 我们在文件顶部添加 @Flow 标签（通知 Flow 需检查此段代码）。我们使用 Flow 的类型注解 限定 skipLogin() 返回值类型必须是 type Action ，由于该Action类型并未在 React Native 及 Redux 里内置，因此在这里我们需要自己对该类型进行定义：123456789101112131415161718192021222324252627export type Action = &#123; type: 'LOADED_ABOUT', list: Array&lt;ParseObject&gt; &#125; | &#123; type: 'LOADED_NOTIFICATIONS', list: Array&lt;ParseObject&gt; &#125; | &#123; type: 'LOADED_MAPS', list: Array&lt;ParseObject&gt; &#125; | &#123; type: 'LOADED_FRIENDS_SCHEDULES', list: Array&lt;&#123; id: string; name: string; schedule: &#123;[key: string]: boolean&#125;; &#125;&gt; &#125; | &#123; type: 'LOADED_CONFIG', config: ParseObject &#125; | &#123; type: 'LOADED_SESSIONS', list: Array&lt;ParseObject&gt; &#125; | &#123; type: 'LOADED_SURVEYS', list: Array&lt;Object&gt; &#125; | &#123; type: 'SUBMITTED_SURVEY_ANSWERS', id: string; &#125; | &#123; type: 'LOGGED_IN', data: &#123; id: string; name: string; sharedSchedule: ?boolean; &#125; &#125; | &#123; type: 'RESTORED_SCHEDULE', list: Array&lt;ParseObject&gt; &#125; | &#123; type: 'SKIPPED_LOGIN' &#125; | &#123; type: 'LOGGED_OUT' &#125; | &#123; type: 'SESSION_ADDED', id: string &#125; | &#123; type: 'SESSION_REMOVED', id: string &#125; | &#123; type: 'SET_SHARING', enabled: boolean &#125; | &#123; type: 'APPLY_TOPICS_FILTER', topics: &#123;[key: string]: boolean&#125; &#125; | &#123; type: 'CLEAR_FILTER' &#125; | &#123; type: 'SWITCH_DAY', day: 1 | 2 &#125; | &#123; type: 'SWITCH_TAB', tab: 'schedule' | 'my-schedule' | 'map' | 'notifications' | 'info' &#125; | &#123; type: 'TURNED_ON_PUSH_NOTIFICATIONS' &#125; | &#123; type: 'REGISTERED_PUSH_NOTIFICATIONS' &#125; | &#123; type: 'SKIPPED_PUSH_NOTIFICATIONS' &#125; | &#123; type: 'RECEIVED_PUSH_NOTIFICATION', notification: Object &#125; | &#123; type: 'SEEN_ALL_NOTIFICATIONS' &#125; | &#123; type: 'RESET_NUXES' &#125; ; 这里我们创建了 Flow 类型别名（ Flow type alias ），限定了 type Action 的样式范围。比如，SKIPPED_LOGIN Action 仅能包含一个自己的type标签， LOADED_SURVEYS Action 则会返回 type 标签以及一个 list 列表。相关 Action Creator 如下：12345678/* from js/actions/surveys.js */async function loadSurveys(): Promise&lt;Action&gt; &#123; const list = await Parse.Cloud.run('surveys'); return &#123; type: 'LOADED_SURVEYS', list, &#125;;&#125; 我们在 app 里使用了大量不同 Action ，强类型检查除了会帮助我们发现类似 type 标签拼写错误这样的低级错误，还会发现如数据格式错误这样的比较重要的问题。 我们在 Reducers 也进行了一样的强类型检查：mp12345678/* from js/reducers/surveys.js */function surveys(state: State = [], action: Action): State &#123; if (action.type === 'LOADED_SURVEYS') &#123; return action.list; &#125; ... return state;&#125; 由于 action 参数被指定为与前面一样的 Action 类型，因此 Reducer 函数必须使用一个有效的 action.type 。我们通过类型别名为 Reducer state 树选项定义样式:12345678910111213141516171819202122232425262728293031323334353637383940/* from js/reducers/user.js */export type State = &#123; isLoggedIn: boolean; hasSkippedLogin: boolean; sharedSchedule: ?boolean; id: ?; name: ?string;&#125;;const initialState = &#123; isLoggedIn: false, hasSkippedLogin: false, sharedSchedule: null, id: null, name: null,&#125;;function user(state: State = initialState, action: Action): State &#123; ...&#125;``` 我们在[数据教程][6]部分曾为你展示过 **initialState** ，现在你会看到，我们是怎样保证 **state** 树选项与 Flow 定义的类型相一致。当 Reducer 发送或者尝试返回任何不符合定义样式的 **state** 时，都会发生 Flow 类型检查错误。请注意， Folw 检查仅在编译阶段运行， Recat Native packger 则会[自动去除][9]-这意味着在代码中使用 Flow 不会造成任何执行性能损失。当然，目前每次想对某些代码进行测试时，我们仍然需要手动运行 Flow 类型检查（通过[ Flow 命令行接口][10]）。不过我们可以通过 Nuclide 在编码时进行这样的查验。##Nuclide：React Native 开发环境[Nuclide 网站][11]上有为 React Native 提供的定制功能的全面介绍。我必须得说， Neculite 是专为 React Native 的 Facebook 研发团队以及 Facebook app 专业研发人员而开发的顶级 React Native IDE 。Nuclite 对 Flow 的集成格外让我们感兴趣。在这里让我们看看 user Reducer 的一段代码：```javascriptif (action.type === 'SKIPPED_LOGIN') &#123; return &#123; isLoggedIn: false, hasSkippedLogin: true, sharedSchedule: null, id: null, name: null, &#125;; &#125; 前面有提到，我们为 Reducer 函数定义了返回值样式。在 Nuclide ，我们可以实时看到错误发生： Your browser does not support the HTML5 video tag. 若我们有遗漏了 State 类型的任何部分，我们会瞬间收到内容为未返回正确对象类型的反馈。这种概率事件在快速构建 app 时会频繁发生。 Nuclite 对所有相关 Flow 类型检查都是如此。这意味着在代码还在编写时，类型错误便能暴露出来，同时我们还能对相关问题进行修正。而这一切无需再等到到开发接近完成时才进行。 这或许并不直观，但确实提高了开发速度。要想在代码中发现遗漏真的是件很困难的事。而在 app 接近开发完成时，这会更加棘手。 ##Jest : 对可能造成 BUG 的改动进行单元测试jest 是一个面向 JavaScipt 的单元测试框架，同时它在 React Native app下也表现不俗。 我们h会用这些单元测试（也被称作回归测试）来确保对已经开发完成的结构化代码的改动并未引入 bug 。 作为例子，下面我们准备通过一个 Jest 测试来保证 Reducer 能够继续按预期处理地图数据：12345678910111213141516171819202122232425262728293031jest.autoMockOff();const Parse = require('parse');const maps = require('../maps');describe('maps reducer', () =&gt; &#123; it('is empty by default', () =&gt; &#123; expect(maps(undefined, &#123;&#125;)).toEqual([]); &#125;); it('populates maps from server', () =&gt; &#123; let list = [ new Parse.Object(&#123;mapTitle: 'Day 1', mapImage: new Parse.File('1.png')&#125;), new Parse.Object(&#123;mapTitle: 'Day 2', mapImage: new Parse.File('2.png')&#125;), ]; expect( maps([], &#123;type: 'LOADED_MAPS', list&#125;) ).toEqual([&#123; id: jasmine.any(String), title: 'Day 1', url: '1.png', &#125;, &#123; id: jasmine.any(String), title: 'Day 2', url: '2.png', &#125;]); &#125;);&#125;); Jest 本身非常易于阅读（注意：我们甚至对 Jest 测试部分都使用了 Flow 来定义类型），不过我们还是会对此进行进一步的分解。在第 4 行，我们引入了地图的 Reducer 函数(js/reducers/maps.js) 这样便能在单元测试中直接调用（Reducer 函数作为 pure functions 能够很容易完成这些）。 第一段测试代码位于第 8 行，目的是确保 Recucer 函数返回一个空数组。观察 js/reducers/maps 处 Reducer 代码，你会发现 state 并未做任何初始化，因此我们会期待期待单元测试结果为返回空数组。 第二段测试代码位于第 12 行，目的是确保地图数据被解析 API 检索到的时候能够被 Reducer 函数转化成 state 树中对应的正确结构。在这个测试中，我们使用假数据完全模拟真实 API 返回数据结构，这将避免API连接问题导致的测试失败。 现在我们已经令跑 Jest 测试成为开发工作流程（比如每次提交 git 前）的一部分。这样我们能确保对现有代码的改动不会令 app 默默阵亡。 由于 Redux Reducers 会改变 state 树，不引入 bug 变得绝对至关重要。由 state 改变引发的 bug 很容易被忽略。因为它们并 不会造成功能不可用，而仅仅只是造成往 Parse Server 发送错误数据的问题。 Reducer 函数的 pure function 特性令它们成为回归测试的理想对象，因为每次我们都可以准确预知它们会如何执行。 ##调试在你试图对 bug 定位或者修复时，手边有一些调试工具的话。我们已经介绍了如何搭建app可视元素调试系统，那这么处理数据呢？ 我们通过 Nuclite 和 Redux Logger middleware 来调用 Chrome 开发者工具（ Chrome Developer Tools ），控制台上展示类似 Actions 或 Reducers 中 state 变动这样的新增 Redux 上下文（ context ）:你可以看到我们是如何通过configurestore来启动这个的：1234567891011121314151617181920/* from js/store/configureStore.js */var createLogger = require('redux-logger');...var isDebuggingInChrome = __DEV__ &amp;&amp; !!window.navigator.userAgent;var logger = createLogger(&#123; predicate: (getState, action) =&gt; isDebuggingInChrome, collapsed: true, duration: true,&#125;);var createF8Store = applyMiddleware(thunk, promise, array, logger)(createStore);function configureStore(onComplete: ?() =&gt; void) &#123; const store = autoRehydrate()(createF8Store)(reducers); persistStore(store, &#123;storage: AsyncStorage&#125;, onComplete); if (isDebuggingInChrome) &#123; window.store = store; &#125; return store;&#125; 在第 5 行，我们通过一些选项创建了 Logger middleware 。 接着，在第 10 行我们调用 Redux 的 applyMiddleware() 函数开始应用 Logger middleware 。这样，我们便可以在控制台上看到日志输出了。 在第4行我们使用全局变量 DEV 来触发调试功能，通过布尔值的改动来在调试模式的开关间进行切换。这一举措除了会决定 Logger middleware 创建后是否记录日志（通过断言选项），还会在第17行 拷贝当前 Store 到 Window object ，如此就可以更容易的通过控制台来直接查看 Store 对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建F8-App part3]]></title>
      <url>%2F2016%2F06%2F08%2F%E6%9E%84%E5%BB%BAF8-App-part3%2F</url>
      <content type="text"><![CDATA[React 和 其扩展 React Native，允许在你构建应用程序，而无需担心你的数据来自哪里，这样你就可以专注于创建应用的UI和逻辑。 在第一章，我们提到如何采用 Parse Server 来持有数据，在 app 中我们将用 Redux 来处理它。在这一部分，我们将解释 Redux 在 React Native 应用中如何工作，以及连接 Parse Server 的简单过程。 在我们讨论 Redux 之前，让我们先看看 React 的数据交互是如何创建 Redux 的。 首先，React 应用如何同数据交互？在MVC应用程序架构中， React 被经常性的视为 ‘View’ 层，但是这样的说法显然欠妥，React 实际上是对 MVC 模式的重新构想。 让我们先看下 MVC 架构的基本思想： 模型层就是数据层。 视图层负责整个应用程序数据的展现。 控制层在应用程序中负责提供数据处理的逻辑操作。 React 可以做到当你创建多个组件组合形成一个视图的时候，每个组件依然可以处理自有逻辑，且只需要提供一个控制器。 1234567891011class Example extends React.Component &#123; render() &#123; // Code that renders the view of the existing data, and // potentially a form to trigger changes to that data through // the handleSubmit function &#125; handleSubmit(e) &#123; // Code that modifies the data, like a controller's logic &#125;&#125;; 在一个 React 应用中，每个组件都有两种不同的数据类型，每一个都有不同的角色： props 当一个组件被创建的时候， props 会被作为参数传递给该组件。如果你有一个按钮，默认的 prop 将会是该按钮的文本。组件并不能改变它们的 props (即它们是不可变的)。 state 是一种可以被任意组件改变任意次数的数据。如果上面的按钮是登录/注销按钮，那么该 state 将记录用户当前的登录状态，并且该按钮也可以访问它，修改它当用户点击了按钮改变其状态。 为了让 React 应用 减少重复， state 被设计为组件库中的最高级父组件所拥有，即前面提到过的container 组件。换句话说，在上个按钮组件例子中，实际上该按钮并没有拥有该属性，你可以在该按钮的父视图中拥有它，然后使用 props 传递相关的 state 数据给子组件。正因为如此，数据仅仅流向任何给定的应用，这会使得 React 更快和模块化。 如果你愿意，你可以从 thinking-in-react 中阅读更多关于制定这些决策的背后想法和原因。 ##存储状态 为了进一步解释在 React 应用中的数据使用技术， Facebook 推荐了 Flux architecture,该架构是一种模式来实现你的应用，而不是一种实际的框架供你使用。我们不在在你的应用中使用 Flux library ,但是我们会使用 Redux 框架，其源于 Flux architecture，所以让我们深入进去吧。 Flux 通过引入 Stores 概念，应用的 state 对象容器，新的工作流用来修改 state 等来扩展 React 的 数据关系： 在 Flux 应用中每个在 Dispatcher 中注册过的 Store 都有一个回调方法。 Views (基于 React 组件) 可以触发 Actions ，基本上每个对象，都包含了一堆刚刚发生事情的数据（例如，可能它包括一些将会被输入到应用中的新数据）和 action type (实质上就是 Action 动作的描述类型常量)。 Action 被发送到 Dispatcher 。 Dispatcher 传递该 Action 到所有 Store 的注册回调。 如果 Store 能告知其被一个 Action影响（因为 action 类型和数据相关），其会自动更新，当然其包含的 state 也会被更新。一旦更新，其会发出变化事件。 特殊的视图被叫做 Controller Views(container components的优雅术语)将会监听这些变化事件，当其抓获某事件，它们知道应该获取新的 Store 数据。 一旦获取到新数据后，它们会调用 setState() ，其会致使在该视图里的组件重新 render 。 你可以看到在 React 应用中 Flux 如何帮助 React 强制执行 one-way flow 策略 ，并且其会使得 React 的数据部分更加优雅和有结构。 我们现在不使用 Flux ,所以在这篇文章里不会再有更多该细节，但是如果你想了解更多，这儿有一些在 Flux 网站的教程可以阅读。 所以 Redux 关 Flux 什么事，在我们应用中实际使用框架 Redux 呢？ Flux 到 ReduxRedux 是 Flux 架构的框架实现，但是其也可以剥离开来，react-redux package 提供的 official bindings provided 可以让其和 React 应用更方便的融合。 在 Redux 中没有 dispatcher ,并且针对整个应用程序只有一个 Store。 在 Redux中，数据流如何工作，在后续我们有更详细的解释，但是这儿我们先介绍几个基本概念： React 组件可以导致 Actions 被触发，例如按钮的点击。 Actions 是一个通过 dispatch 方法 被发送到 Store 的对象（包括一个 type 标签和 Action相关的其他数据）。 然后 Store 承载着相关 Action ,同当前 state 树（ state 树是一个单独的对象包含了所有的 state 数据）将其发送到 Reducers。 Reducer 是一个纯函数，它维持着之前的状态和动作，然后返回一个基于任何变化的动作的 state。 Redux 应用只能包含一个 Reducer，但是大部分应用最后都会有几个，并且每个都会处理 state 的不同部分（我们将讨论这个） Store 接收到新的 state ，然后替换掉旧的。这里值得注意的是，当我们讨论 state 更新时，这其实是技术上的取代。 当 state 发生变化时， Store 触发变化事件。 任何订阅了该变化事件的 React 组件都会收到来自 Store 的新 state。 组件随 state 而更新。 该工作流可以通过下图简单总结： ![redux_flowchart](http://makeitopen.com/static/images/redux_flowchart.png） 你可以看到数据是如何遵循一个明确的单向通道，没有重叠或相反的方向流动。这也说明 Redux 可以将 app 的每一部分细分。 Store 只关注 state ,视图中的组件只关注展示数据和触发事件， Actions 只关注 state 的变化和其内部的数据。 Reducers 只关注融合旧的 state 和 actions 到新的 state 。当你阅读器源代码并理解它时，你会发现一切都是模块化，优雅和具有明确目的的。 Flux 有一些其他的好处： Actions 是触发 state 改变的唯一方式，且该过程不经过 UI 组件，并且因为 Reducer ，让其很有秩序，远离竞争。 state 变得不可变，并且有一系列的 state 。每一个都因为代一个独特的变化而被创建。这让你在应用程序中能更简单和清晰的追踪 state 的状态。 ##将它们融合在一起 所以现在，我们已经讨论完抽象的数据流，现在让我们来看看我们的 React Native 应用如何使用它们，以及在这个过程中我们学到的东西。 StoreRedux 文档 非常好的解释了如何创建简单的 Store,所以我们将会将设您已经阅读那里的基本知识，并跳过一点点内容，包括 Store 的几个额外参数。 Store 的离线同步我们讨论过本地离线存储的必需性，这样应用程序才可以在低信号或无信号条件下工作（在技术会议上尤为重要）。幸运的是，因为我们正在使用 Redux，在我们的 app 中我们可以使用一些很简单的模块，其被叫做 Redux Persist 。 在我们的 Store 中我们也会用到 中间件 ,我们将更多地讨论一些在测试阶段我们用的一些东西。但是总的来说，中间件让你能够在 Action 被分发和到达 Reducer 之前添加一些额外的逻辑操作（这对日志，崩溃报告，异步 APIs 等很有帮助）。 123456789/* js/store/configureStore.js */var createF8Store = applyMiddleware(...)(createStore);function configureStore(onComplete: ?() =&gt; void) &#123; const store = autoRehydrate()(createF8Store)(reducers); persistStore(store, &#123;storage: AsyncStorage&#125;, onComplete); ... return store;&#125; 在这里，嵌套函数的语法可能有些让人迷惑（其中的一些函数返回将另一个函数作为参数），所以在这里扩展下： 12345678910111213141516/* js/store/configureStore.js */// 1var middlewareWrapper = applyMiddleware(...);// 2var createF8Store = middlewareWrapper(createStore(reducers));function configureStore(onComplete: ?() =&gt; void) &#123; // 3 const rehydrator = autoRehydrate(); const store = rehydrator(createF8Store); // 4 persistStore(store, &#123;storage: AsyncStorage&#125;, onComplete); ... return store;&#125; 在第一行代码中，我们使用 Redux 的 appluMiddleware() 启动中间件（如果你想知道更多，请阅读 Redux appluMiddleware 文档 该函数用于实例 Store 对象）。 所以在第二行代码中，我们我们将 Redux的 createStore() 方法包裹在了 middlewareWrapper . createStore() 方法返回一个 Store 对象 ，middlewareWrapper() 通过中间件扩展它，最终结果保存在 createF8Store 中。 然后我们配置我们的 Store 对象。 Persist’s autoRehydrate() 是另外一个扩展 Store方法（和 applyMiddleware() 一样，其返回一个函数），我们更新现有的 Store 对象（第三行代码）。 autoRehydrate() 方法事先将一个 Store 对象保存到本地，然后根据 state 自动更新其状态。 第四行的 Persist package’s persistStore() （我们使用到了 React Native 的 异步存储系统） 函数是实际的将 app 的 Store 存储到本地。 autoRehydrate() 和 persistStore() 函数就是我们需要离线同步功能的全部代码。 现在，不管何时应用程序断开网络连接，Store 最近的副本依然会被存储到本地（包括通过 API 来抓取解析的数据），从用户角度来看，我们的应用仍然可以正常工作。关于更多信息，你可以阅读 technical details of how the Redux Persist package works ,但本质上我们已经完成了构建我们的 Store 。 Reduers在上一节，我们解释了 Redux ,我们也因此引入了一个 Reducer 对象。然而在每个应用中，会有很多个 Reducers 对象。每个对象都对应着 state 的不同部分。举个例子，在一个可评论的应用中，你可能需要一个 reducer 关联到登录状态，其他的关联到其他的评论数据。 在 F8 应用中，我们将 reducers 存储在 js/reducers 中。这是 user.js 的简写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* js/reducers/user.js */...import type &#123;Action&#125; from '../actions/types';...// 1const initialState = &#123; isLoggedIn: false, hasSkippedLogin: false, sharedSchedule: null, id: null, name: null,&#125;;// 2function user(state: State = initialState, action: Action): State &#123; // 3 if (action.type === 'LOGGED_IN') &#123; // 6 let &#123;id, name, sharedSchedule&#125; = action.data; if (sharedSchedule === undefined) &#123; sharedSchedule = null; &#125; return &#123; isLoggedIn: true, hasSkippedLogin: false, sharedSchedule, id, name, &#125;; &#125; if (action.type === 'SKIPPED_LOGIN') &#123; return &#123; isLoggedIn: false, hasSkippedLogin: true, sharedSchedule: null, id: null, name: null, &#125;; &#125; // 4 if (action.type === 'LOGGED_OUT') &#123; return initialState; &#125; // 5 if (action.type === 'SET_SHARING') &#123; return &#123; ...state, sharedSchedule: action.enabled, &#125;; &#125; if (action.type === 'RESET_NUXES') &#123; return &#123;...state, sharedSchedule: null&#125;; &#125; return state;&#125;module.exports = user; 正如你所知， 这个 reducer 包含了 登录/登出 操作，以及特定的用户参数修改。让我们一点一点分析。 注意：在第六段，我们使用了 ES2015 的 destructuring assignment ，其将左边的变量分配给 action.data 初始状态 在我们定义初始状态之前，这符合流动式命名习惯（我们将会在 React Native 应用的测试中详细解释）。 initialState 定义了 state 的一部分值，该值被 Reducer 处理，应用会首次加载它或者以前在其上的任何同步存储。 Reducer 方法 然后，我们编写 Reducer 的实例，其实相对来说还是很简单。 state 和 Action (之后我们会讨论) 被作为参数， initialState 作为 state 的默认值（我们将参数使用流式类型注解，同样的，我们会在 React Native 应用的测试部分提到）。然后，我们使用接收到的 Action ,具体为 ‘type’ 标签，返回一个新的改变了的 state 。 举个例子，如果第四段的 LOGGED_OUT Action 被分派（由于用户点击了登出按钮），我们将会重置 state 的一部分值为 initialState 。 如果第三段 LOGGED_IN Action 发生，你会看到应用将会使用余下数据，返回新的 state ，该 state 和 常规变化例如 isLoggedIn,或者用户输入数据变化 例如 name 都将冲突。 还有个方法我们也可以看下，这便是第五段的 SET_SHARING Action 类型。 其非常有趣因为 ...state 注解被使用。在 React 中，注解让对象的分配更具兼容性和可读性，并且其会创建一个对象，然后拷贝已经存在的 state ,最后单独更新 sharedSchedule 的值。 你可以看到 Reducer 的结构是如此的简单和可读 - 定义一个 initialState ，构建一个传入 state 和 Action ,返回一个新的 state 的函数。 reducers 还有一个大的规则，我们引用 Redux 文档的内容： “记住，reducer 必须是单纯的。提供相同的参数，其应该计算下一个状态然后返回它。没有意外，没有副作用，没有 API 调用，没有突变，只有计算。” 另外一件事需要注意的是：看看 js/reducers/notifications.js ,其有针对 LOGGED_OUT 动作类型的另一个引用。我们之前提到过，但是现在依然需要重复下 - 每一个 reducer 通常是在一个动作被派发后被调用，所以多个 reducers 可能会基于相同的动作来更新不同的 state 。 Actions 让我们仔细看下登录相关的动作，看看它们的代码位置： 123456/* from js/actions/login.js */function skipLogin(): Action &#123; return &#123; type: 'SKIPPED_LOGIN', &#125;;&#125; 这是一个简单的Action creator (这个 creator 函数返回的对象实际上是一个 Action)，但是这让你看到了最基本的结构 - 每个动作可以简单的视为一个包含了 type 标签的对象。然后 reducers 可以使用该 type 来更新 state 。 同样，我们可以为 type 添加一些数据： 1234567/* from js/actions/filter.js */function applyTopicsFilter(topics): Action &#123; return &#123; type: 'APPLY_TOPICS_FILTER', topics, &#125;;&#125; 在这儿，动作创造者接收了一个参数，并且将其插入到了动作对象中。 然后，我们有一些动作制造者会执行额外的逻辑以及返回 Action 对象。在这个例子中，我们也会使用到一个叫做 ThunkAction 的 动作（Redux 建议你创建点类似这样的东西来减少模板） - 这种特殊类型的动作制造者返回的是一个函数而不是一个动作。在这种情况下，登出动作制造者返回一个执行一些登出相关的逻辑函数，然后分配到一个 Action 。 123456789101112/* from js/actions/login.js */function logOut(): ThunkAction &#123; return (dispatch) =&gt; &#123; Parse.User.logOut(); FacebookSDK.logout(); ... return dispatch(&#123; type: 'LOGGED_OUT', &#125;); &#125;;&#125; (注意，在这个例子中，我们也会使用到 Arrow function 语法) 异步动作举个例子，如果你同任何 APIs 交互，你需要一些异步的动作制造者。 Redux 在这方面有个相当复杂的方式来实现异步，但是由于我们在使用 React Native , 我们可以使用到 ES7 的 await 函数，这极大简化了异步过程： 12345678/* from js/actions/config.js */async function loadConfig(): Promise&lt;Action&gt; &#123; const config = await Parse.Config.get(); return &#123; type: 'LOADED_CONFIG', config, &#125;;&#125; 在这里，我们使用 一个 API 调用去解析去抓取一些应用程序的配置参数。任何像这样的 API 调用获取网络资源都需要耗费一定的时间。动作不会被立即分配，动作创造者首先等待 API 调用的结果，然后一旦数据有效，动作对象（负载着 API 数据）会被立即返回。 其异步调用的一个好处是，由于我们在等待 Parse.Config 调用的结果，其他的异步操作可以做其自己的工作，这样我们可以同时又多个操作，其会自动提高效率。 绑定到组件现在，在我们应用的 setup 函数中链接 Redux 逻辑到 React ： 123456789101112131415161718192021222324252627/* from js/setup.js */function setup(): React.Component &#123; // ... other setup logic class Root extends React.Component &#123; constructor() &#123; super(); this.state = &#123; isLoading: true, store: configureStore(() =&gt; this.setState(&#123;isLoading: false&#125;)), &#125;; &#125; render() &#123; if (this.state.isLoading) &#123; return null; &#125; return ( // 1 &lt;Provider store=&#123;this.state.store&#125;&gt; &lt;F8App /&gt; &lt;/Provider&gt; ); &#125; &#125; return Root;&#125; 我们使用官方的 React 和 Redux 绑定, 因此我们可以使用 组件 。 这个 Provider 让我们的 Store 可以和任何我们创建的组件通信： 123456789101112131415/* from js/F8App.js */var F8App = React.createClass(&#123; ...&#125;)// 1function select(state) &#123; return &#123; notifications: state.notifications, isLoggedIn: state.user.isLoggedIn || state.user.hasSkippedLogin, &#125;;&#125;// 2module.exports = connect(select)(F8App); 在上面，我们展示了一部分 组件的代码 - 我们整个应用的父组件。 上面第一个方被用来获取 Redux Store，然后从中获取一些数据，针对我们的 &lt;F8App&gt; 组件插入到 props。在这种情况下，我们希望通知的数据和用户登录状态的数据成为组件的 props，这样其会根据每一次 Store 的改变而更新状态。 我们可以使用 React-Redux 的 connect() 方法来实现它 - connect() 有一个参数叫做 mapStateToProps，其会负载一个方法，当一个 Store 更新，该方法就会被调用。 所以当我们应用的 Store 更新时，select() 将会和被作为参数的新 state 一起被调用。select()返回一个包含了我们想从新 state中获取的数据（自在这个例子中，是notifications和isLoggedIn）,然后 第二段的connect() 融合数据到 &lt;F8App&gt; 组件的 props。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* from js/F8App.js */var F8App = React.createClass(&#123; ... componentDidMount: function() &#123; ... // 1 if (this.props.notifications.enabled &amp;&amp; !this.props.notifications.registered) &#123; ... &#125; ... &#125;, ...&#125;)``` 现在我们有个 `&lt;F8App&gt;` 组件，当任何新的已经通过 `select()` 方法订阅了的 `state`数据，都会被更新，其可以通过我们的 props 访问。但是我们如何从一个组件里分派动作？### 从组件中分派动作为了知道我们如何连接动作到组件，让我们看看 `&lt;GeneralScheduleView&gt;` 相关部分：```javascript/* from js/tabs/schedule/GeneralScheduleView.js */class GeneralScheduleView extends React.Component &#123; props: Props; constructor(props) &#123; super(props); this.renderStickyHeader = this.renderStickyHeader.bind(this); ... this.switchDay = this.switchDay.bind(this); &#125; render() &#123; return ( &lt;ListContainer title="Schedule" backgroundImage=&#123;require('./img/schedule-background.png')&#125; backgroundShift=&#123;this.props.day - 1&#125; backgroundColor=&#123;'#5597B8'&#125; data=&#123;this.props.data&#125; renderStickyHeader=&#123;this.renderStickyHeader&#125; ... /&gt; ); &#125; ... renderStickyHeader() &#123; return ( &lt;View&gt; &lt;F8SegmentedControl values=&#123;['Day 1', 'Day 2']&#125; selectedIndex=&#123;this.props.day - 1&#125; selectionColor="#51CDDA" onChange=&#123;this.switchDay&#125; /&gt; ... &lt;/View&gt; ); &#125; ... switchDay(page) &#123; this.props.switchDay(page + 1); &#125;&#125;// 1module.exports = GeneralScheduleView; 同样，这段代码已经为了便于学习很大程度上简化了，但是我们现在可以在第一段添加和修改一些代码来连接这个 容器组件到 Redux store： 123456789101112131415/* from js/tabs/schedule/GeneralScheduleView.js */function select(store) &#123; return &#123; day: store.navigation.day, data: data(store), &#125;;&#125;function actions(dispatch) &#123; return &#123; switchDay: (day) =&gt; dispatch(switchDay(day)), &#125;&#125;module.exports = connect(select, actions)(GeneralScheduleView); 这一次有一些不同 - 我们提供了 React-Redux 的 connect() 方法。总的来说，执行 actions() 内部的动作创造者到组件的 props,然后将其包裹在 dispatch()方法，这样它们才能立即分发一个 Action 。 如何工作让我们看看实际的组件: ![](http://makeitopen.com/static/images/redux_flowchart.png） 利用 ’Day 1’ 在 renderStickyHeader() 中触发 onChange 事件，然后在组件内部的 switchDay() 方法被调用，该方法分发 this.props.switchDay() 动作创造者。在我们的动作文件内，我们可以看到这样一个动作创造者： 12345/* from js/actions/index.js */switchDay: (day): Action =&gt; (&#123; type: 'SWITCH_DAY', day,&#125;) 在导航 Reducer 内部，我们可以看到一个修改的 day 值产生一个新的 state 树： 1234/* from js/reducers/navigation.js */ if (action.type === 'SWITCH_DAY') &#123; return &#123;...state, day: action.day&#125;; &#125; 这个 Reducer（以及任何其他那些可能监视 SWITCH_DAY 动作的 Reducers ）返回新的 state 到 Store中，其更新自己并且发送一个改变事件。 而由于通过连接 &lt;GeneralScheduleView&gt; 连接到 Redux Store,我们还订阅了 Store 的变化状态。 什么是解析服务器在这个教程中，你希望你能够获取到大量新的信息，所以让我们快速展示我们如何连接 React Native 应用到我们的解析服务器数据后端，以及相关 API: 12345Parse.initialize( 'PARSE_APP_ID', 'PARSE_JAVASCRIPT_KEY' ); Parse.serverURL = 'http://exampleparseserver.com:1337/parse' 就这样，在 React Native 中我们通过 解析 API 建立连接。 是的，因为我们现在使用的是 Parse + React SDK ,我们有非常简单的SDK接入。 解析和动作当然，我们希望能够查询（例如，在我们的Actions中）……很多的查询。对于那些动作创造者来说没什么特别的，它们是我们之前提到的相同的异步操作。然而，因为有非常多的简单的 Parse API 查询需要初始化应用，我们想大量减少样板。在我们的基本动作文件中，我们创建基本的动作构建者： 123456789/* from js/actions/index.js */function loadParseQuery(type: string, query: Parse.Query): ThunkAction &#123; return (dispatch) =&gt; &#123; return query.find(&#123; success: (list) =&gt; dispatch((&#123;type, list&#125;: any)), error: logError, &#125;); &#125;;&#125; 然后我们就可以简单的多次复用该代码： 12loadMaps: (): ThunkAction =&gt; loadParseQuery('LOADED_MAPS', new Parse.Query(Maps)), loadMaps() 变成了一个动作创建器，其将会运行一个简单的解析查询针对所有存储的地图数据，然后将其单独传递当查询结束时。loadMaps() 以及其他解析数据操作的动作可以在整个应用的 componentDidMount（） 方法中找到，这意味着当应用第一次打开时，其需要拉去所有的解析数据。 解析和 Reducers我们已经减少了重复的动作，但是同时我们也想减少在我们 Reducers 内部的模板。这些模板将会从 动作负载中收到一些解析 API 的数据，并且必须将其映射到 state。我们针对解析数据创建单个基本 Reducer ： 12345678910111213/* from js/reducers/createParseReducer.js */function createParseReducer&lt;T&gt;( type: string, convert: Convert&lt;T&gt;): Reducer&lt;T&gt; &#123; return function(state: ?Array&lt;T&gt;, action: Action): Array&lt;T&gt; &#123; if (action.type === type) &#123; // Flow can't guarantee &#123;type, list&#125; is a valid action return (action: any).list.map(convert); &#125; return state || []; &#125;;&#125; 这是个简单的 Reducer (有大量流式类型注解)，但是让我们看看其如何同基于关闭它的子 Reducers工作。 123456789101112131415161718/* from js/reducers/faqs.js */const createParseReducer = require('./createParseReducer');export type FAQ = &#123; id: string; question: string; answer: string;&#125;;function fromParseObject(map: Object): FAQ &#123; return &#123; id: map.id, question: map.get('question'), answer: map.get('answer'), &#125;;&#125;module.exports = createParseReducer('LOADED_FAQS', fromParseObject); 所以不用每次去重复创建一份 createParseReducer 代码，我们只需要简单的传递一个对象给基本的 Reducer，其会将 API 数据映射到我们的 state 上。 现在，我们的应用，拥有一个结构良好且易于理解的数据流，可以连接到我们的解析服务器，甚至能够离线同步我们的 Store 到本地存储。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建F8-App part2]]></title>
      <url>%2F2016%2F06%2F03%2F%E6%9E%84%E5%BB%BAF8-App-part2%2F</url>
      <content type="text"><![CDATA[React Native 的一大优势是：可以只用一种语法编写分别运行在 iOS 和 Android 平台上的程序，且可重用部分应用逻辑。然而，与“一次编写，到处运行”的理念不同的是，React Native 的哲学是“一次学习，到处编写”。如此一来，即使用 React Native 编写不同平台的程序，也可以尽可能贴合每个平台的特性。从 UI 的角度来看，每个平台都有自己独特的视觉风格、UI 范例甚或是技术层面的功能，那我们设计出一个统一的 UI 基础组件，然后再按照各平台特性进行调整岂不乐乎？ 准备工作在后续的所有教程中，我们会仔细解读 App 的源代码，请克隆一份源代码到本地可访问的路径，然后根据配置说明在本地运行 App。在本章的教程中，你只需要阅读相关源代码。 React Native 思维模式在你写任何 React 代码之前，请认真思考这个至关重要的问题：如何才能尽可能多地重用代码？ React Native 的理念是针对每个平台分而治之，代码重用的做法看起来与之相违背，好像我们就应该为每个平台定制其专属的视觉组件一样，但实际上我们仍需努力让每个平台上的代码尽可能多地统一。 构建一套 React Native 应用视觉组件的关键点在于如何最好地实现平台抽象。开发人员和设计师可以列出应用中需要重用的组件，例如按钮、容器、列表行，头部等等，只有在必要的时候才单独为每个平台设计特定的组件。 当然，有一些组件相对于其它组件而言更为复杂，我们先一起来看看 F8 应用中不同的组件有什么区别。 各种各样的小组件请看 F8 应用的示例图： 在 iOS 版本中，我们用 iOS 系统中很常见的圆角边框风格来切分 Tab 控制；在 Android 版本中，我们用下划线的风格来标示这个组件。而这两个控制组件的功能其实完全相同。 所以，即使两者样式稍有不同，但是实现的功能相同，所以我们可以用同一套代码抽象此处的逻辑，从而可以尽可能多地重用代码。我们针对像这样的小组件做了很多跨平台重用逻辑代码的案例，比如一个简单的文本按钮，在每个平台上我们都会设计不同的 hover 和 active 状态的样式，但是除开这些视觉上的细微的差异外，逻辑功能完全相同。所以我们总结了一个抽象 React Native 视觉组件的最佳实践方法：设计一套相同的逻辑代码，然后在控制语句中编写其余需要差异化的部分。 以下是这个组件的示例代码（来自 &lt;F8SegmentedControl&gt;）： 1234567891011121314151617181920212223242526272829303132333435363738/* from js/common/F8SegmentedControl.js */class Segment extends React.Component &#123; props: &#123; value: string; isSelected: boolean; selectionColor: string; onPress: () =&gt; void; &#125;;render() &#123; var selectedButtonStyle; if (this.props.isSelected) &#123; selectedButtonStyle = &#123; borderColor: this.props.selectionColor &#125;; &#125; var deselectedLabelStyle; if (!this.props.isSelected &amp;&amp; Platform.OS === 'android') &#123; deselectedLabelStyle = styles.deselectedLabel; &#125; var title = this.props.value &amp;&amp; this.props.value.toUpperCase(); var accessibilityTraits = ['button']; if (this.props.isSelected) &#123; accessibilityTraits.push('selected'); &#125; return ( &lt;TouchableOpacity accessibilityTraits=&#123;accessibilityTraits&#125; activeOpacity=&#123;0.8&#125; onPress=&#123;this.props.onPress&#125; style=&#123;[styles.button, selectedButtonStyle]&#125;&gt; &lt;Text style=&#123;[styles.label, deselectedLabelStyle]&#125;&gt; &#123;title&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; ); &#125;&#125; 在这段代码中，我们为每一种平台分别应用了不同的样式（用到了 React Native 的 Platform 模块）。各平台中的 Tab 按钮都应用了相同的通用样式，同时也根据各平台特性定制了独占样式（同样出自 &lt;F8SegmentedControl&gt;）： 1234567891011121314151617181920212223242526272829303132333435363738394041/* from js/common/F8SegmentedControl.js */var styles = F8StyleSheet.create(&#123; container: &#123; flexDirection: 'row', backgroundColor: 'transparent', ios: &#123; paddingBottom: 6, justifyContent: 'center', alignItems: 'center', &#125;, android: &#123; paddingLeft: 60, &#125;, &#125;, button: &#123; borderColor: 'transparent', alignItems: 'center', justifyContent: 'center', backgroundColor: 'transparent', ios: &#123; height: HEIGHT, paddingHorizontal: 20, borderRadius: HEIGHT / 2, borderWidth: 1, &#125;, android: &#123; paddingBottom: 6, paddingHorizontal: 10, borderBottomWidth: 3, marginRight: 10, &#125;, &#125;, label: &#123; letterSpacing: 1, fontSize: 12, color: 'white', &#125;, deselectedLabel: &#123; color: 'rgba(255, 255, 255, 0.7)', &#125;,&#125;); 在这段代码中我们使用了一个改编自 React Native StyleSheet API 的函数 F8StyleSheet，它可以针对各平台分别进行样式转换操作： 1234567891011121314export function create(styles: Object): &#123;[name: string]: number&#125; &#123; const platformStyles = &#123;&#125;; Object.keys(styles).forEach((name) =&gt; &#123; let &#123;ios, android, ...style&#125; = &#123;...styles[name]&#125;; if (ios &amp;&amp; Platform.OS === 'ios') &#123; style = &#123;...style, ...ios&#125;; &#125; if (android &amp;&amp; Platform.OS === 'android') &#123; style = &#123;...style, ...android&#125;; &#125; platformStyles[name] = style; &#125;); return StyleSheet.create(platformStyles);&#125; 在这个 F8StyleSheet 函数中我们解析了前面示例代码中的 styles 对象，如果我们发现了匹配当前平台的 ios 或 android 键值，就会应用相应的样式，如果都没有，则应用默认样式。以此看来，减少代码重复的另一种做法是：尽可能多地重用通用样式代码。 现在，我们已经可以在我们的App中重用这个组件了，它也可以根据不同的平台自动匹配相应的样式。 分离复杂差异如果一个组件在各平台上的差异不仅仅是样式的不同，也存在大量的逻辑代码差异，那我们就需要换一种方式了。正如下图所示，iOS 和 Android 平台中最高阶的菜单导航组件就有非常大的差异： 正如你所见，在 iOS 版本中我们在屏幕底部放了一个固定的 Tab，而在 Android 版本中，我们却实现了一种可划出的侧边栏。这两种组件其实是本质上的不同，况且一般来说，在 Android 应用中，这种侧边栏通常还会包含更多的菜单选项，例如：退出登录。 你当然可以将这两种菜单模式写到一个组件中去，但是这个组件会变得异常臃肿，所有的差异不得不通过大量的分支语句来实现，你一定会在不久的将来对这段代码感到陌生难懂。 其实，我们可以用 React Native 内建的平台特定的扩展来解决这个问题。我们可以创建两个独立的应用，在下面的示例中我们会创建两个组件，分别命名为：F8TabsView.ios.js 和 F8TabsView.android.js。React Native 会自动检测当前平台并根据扩展命名加载相应的组件。 内建UI组件在每一个 FBTabsView 组件中，我们也可以重用一些内建的 React Native UI 组件，Android 版本使用的是 DrawerLayoutAndroid（很显然，只在 Android 中可用）： 1234567891011121314/* from js/tabs/F8TabsView.android.js */render() &#123; return ( &lt;DrawerLayoutAndroid ref="drawer" drawerWidth=&#123;300&#125; drawerPosition=&#123;DrawerLayoutAndroid.positions.Left&#125; renderNavigationView=&#123;this.renderNavigationView&#125;&gt; &lt;View style=&#123;styles.content&#125; key=&#123;this.props.activeTab&#125;&gt; &#123;this.renderContent()&#125; &lt;/View&gt; &lt;/DrawerLayoutAndroid&gt; );&#125; 在第8行代码中，我们在当前的类中显式地为 drawer 组件指定了 renderNavigationView() 函数。这个函数会返回 drawer 中渲染出来的内容。在这个示例中，我们渲染的是一个包含在自定义 MenuItem 组件(点击查看 MenuItem.js)中的 ScrollView 组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* from js/tabs/F8TabsView.android.js */renderNavigationView() &#123; ... return( &lt;ScrollView style=&#123;styles.drawer&#125;&gt; &lt;MenuItem title="Schedule" selected=&#123;this.props.activeTab === 'schedule'&#125; onPress=&#123;this.onTabSelect.bind(this, 'schedule')&#125; icon=&#123;scheduleIcon&#125; selectedIcon=&#123;scheduleIconSelected&#125; /&gt; &lt;MenuItem title="My F8" selected=&#123;this.props.activeTab === 'my-schedule'&#125; onPress=&#123;this.onTabSelect.bind(this, 'my-schedule')&#125; icon=&#123;require('./schedule/img/my-schedule-icon.png')&#125; selectedIcon=&#123;require('./schedule/img/my-schedule-icon-active.png')&#125; /&gt; &lt;MenuItem title="Map" selected=&#123;this.props.activeTab === 'map'&#125; onPress=&#123;this.onTabSelect.bind(this, 'map')&#125; icon=&#123;require('./maps/img/maps-icon.png')&#125; selectedIcon=&#123;require('./maps/img/maps-icon-active.png')&#125; /&gt; &lt;MenuItem title="Notifications" selected=&#123;this.props.activeTab === 'notifications'&#125; onPress=&#123;this.onTabSelect.bind(this, 'notifications')&#125; badge=&#123;this.state.notificationsBadge&#125; icon=&#123;require('./notifications/img/notifications-icon.png')&#125; selectedIcon=&#123;require('./notifications/img/notifications-icon-active.png')&#125; /&gt; &lt;MenuItem title="Info" selected=&#123;this.props.activeTab === 'info'&#125; onPress=&#123;this.onTabSelect.bind(this, 'info')&#125; icon=&#123;require('./info/img/info-icon.png')&#125; selectedIcon=&#123;require('./info/img/info-icon-active.png')&#125; /&gt; &lt;/ScrollView&gt; );&#125; 相比之下，iOS 版本直接在 render() 函数中使用了一个不同的内建组件，TabBarIOS： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* from js/tabs/F8TabsView.ios.js */render() &#123; var scheduleIcon = this.props.day === 1 ? require('./schedule/img/schedule-icon-1.png') : require('./schedule/img/schedule-icon-2.png'); var scheduleIconSelected = this.props.day === 1 ? require('./schedule/img/schedule-icon-1-active.png') : require('./schedule/img/schedule-icon-2-active.png'); return ( &lt;TabBarIOS tintColor=&#123;F8Colors.darkText&#125;&gt; &lt;TabBarItemIOS title="Schedule" selected=&#123;this.props.activeTab === 'schedule'&#125; onPress=&#123;this.onTabSelect.bind(this, 'schedule')&#125; icon=&#123;scheduleIcon&#125; selectedIcon=&#123;scheduleIconSelected&#125;&gt; &lt;GeneralScheduleView navigator=&#123;this.props.navigator&#125; onDayChange=&#123;this.handleDayChange&#125; /&gt; &lt;/TabBarItemIOS&gt; &lt;TabBarItemIOS title="My F8" selected=&#123;this.props.activeTab === 'my-schedule'&#125; onPress=&#123;this.onTabSelect.bind(this, 'my-schedule')&#125; icon=&#123;require('./schedule/img/my-schedule-icon.png')&#125; selectedIcon=&#123;require('./schedule/img/my-schedule-icon-active.png')&#125;&gt; &lt;MyScheduleView navigator=&#123;this.props.navigator&#125; onJumpToSchedule=&#123;() =&gt; this.props.onTabSelect('schedule')&#125; /&gt; &lt;/TabBarItemIOS&gt; &lt;TabBarItemIOS title="Map" selected=&#123;this.props.activeTab === 'map'&#125; onPress=&#123;this.onTabSelect.bind(this, 'map')&#125; icon=&#123;require('./maps/img/maps-icon.png')&#125; selectedIcon=&#123;require('./maps/img/maps-icon-active.png')&#125;&gt; &lt;F8MapView /&gt; &lt;/TabBarItemIOS&gt; &lt;TabBarItemIOS title="Notifications" selected=&#123;this.props.activeTab === 'notifications'&#125; onPress=&#123;this.onTabSelect.bind(this, 'notifications')&#125; badge=&#123;this.state.notificationsBadge&#125; icon=&#123;require('./notifications/img/notifications-icon.png')&#125; selectedIcon=&#123;require('./notifications/img/notifications-icon-active.png')&#125;&gt; &lt;F8NotificationsView navigator=&#123;this.props.navigator&#125; /&gt; &lt;/TabBarItemIOS&gt; &lt;TabBarItemIOS title="Info" selected=&#123;this.props.activeTab === 'info'&#125; onPress=&#123;this.onTabSelect.bind(this, 'info')&#125; icon=&#123;require('./info/img/info-icon.png')&#125; selectedIcon=&#123;require('./info/img/info-icon-active.png')&#125;&gt; &lt;F8InfoView navigator=&#123;this.props.navigator&#125; /&gt; &lt;/TabBarItemIOS&gt; &lt;/TabBarIOS&gt; );&#125; 显而易见，尽管 iOS 菜单接受了相同的数据，但是它的结构略有不同。我们并没有用一个独立的函数创建菜单元素，而是将这些元素作为父级菜单的子元素插入进来，正如 TabBarItemIOS 组件这样。这里的 TabBarItem 与 Android 中 的 MenuItem 本质上是相同的，唯一的区别是在 Android 组件中我们会定义一个独立的主 View 组件： 123&lt;View style=&#123;styles.content&#125; key=&#123;this.props.activeTab&#125;&gt; &#123;this.renderContent()&#125;&lt;/View&gt; 然后当一个 tab 改变时改变这个组件（通过 renderContent() 函数），而 iOS 组件则会有多个分离的 View 组件，例如： 1234&lt;GeneralScheduleView navigator=&#123;this.props.navigator&#125; onDayChange=&#123;this.handleDayChange&#125;/&gt; 这是 TabBarItem 的一部分，可以点击使它们可见。 设计迭代周期当你构建任何应用，无论是在移动平台还是 web 环境下，调整适配的 UI 元素是非常痛苦的。如果工程师和设计师共同协作，会使整个过程慢下来。 React Native 包含了一个实时重载的 debug 功能，可以当 JavaScript 改变时触发刷新应用。这可以在极大程度上减少设计迭代过程，一旦改变了组件样式并保存后，你会立即看到更新的样式。 但是如果组件在不同条件下看起来不同怎么办呢？举个例子，一个按钮组件可能有一个默认样式，也分别包含按下、执行任务中、执行任务完成时的样式。 为了避免每次都与应用交互，我们内建了一个用于 debug 视觉效果的 Playgroud 组件： 12345678910111213141516171819202122/* from js/setup.js */class Playground extends React.Component &#123; constructor(props) &#123; super(props); const content = []; const define = (name: string, render: Function) =&gt; &#123; content.push(&lt;Example key=&#123;name&#125; render=&#123;render&#125; /&gt;); &#125;; var AddToScheduleButton = require('./tabs/schedule/AddToScheduleButton'); AddToScheduleButton.__cards__(define); this.state = &#123;content&#125;; &#125; render() &#123; return ( &lt;View style=&gt; &#123;this.state.content&#125; &lt;/View&gt; ); &#125;&#125; 其实我们只是创建了一个可交换加载的空视图，将其与一些示例定义整合到其中一个 UI 组件中，正如下面这段 AddToScheduleButton.js 所示： 12345678910111213141516/* from js/tabs/schedule/AddToScheduleButton.js */module.exports.__cards__ = (define) =&gt; &#123; let f; setInterval(() =&gt; f &amp;&amp; f(), 1000); define('Inactive', (state = true, update) =&gt; &lt;AddToScheduleButton isAdded=&#123;state&#125; onPress=&#123;() =&gt; update(!state)&#125; /&gt;); define('Active', (state = false, update) =&gt; &lt;AddToScheduleButton isAdded=&#123;state&#125; onPress=&#123;() =&gt; update(!state)&#125; /&gt;); define('Animated', (state = false, update) =&gt; &#123; f = () =&gt; update(!state); return &lt;AddToScheduleButton isAdded=&#123;state&#125; /&gt;; &#125;);&#125;; 我们可以将这个应用转化为一个 UI 预览工具： 在这个示例中为这个按钮定义了按下和抬起两种状态，第三个按钮在这两者的状态之间不断循环，以此来预览过渡的动画效果。 现在，我们可以跟设计师一起快速调整基础组件的视觉样式了。 如果想用这个功能，&lt;Playground&gt; 组件必须在任何 React Native 应用中都可用，我们需要在 setup() 函数中交换一些代码来加载 &lt;Playground&gt; 组件： 123456789/* from js/setup.js */render() &#123; ... return ( &lt;Provider store=&#123;this.state.store&#125;&gt; &lt;F8App /&gt; &lt;/Provider&gt; );&#125; 变为 123456789/* in js/setup.js */render() &#123; ... return ( &lt;Provider store=&#123;this.state.store&#125;&gt; &lt;Playground /&gt; &lt;/Provider&gt; );&#125; 当然，你也可以修改 &lt;Playground&gt; 组件，使其能够改变引入的其它组件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建F8-App part1]]></title>
      <url>%2F2016%2F05%2F28%2F%E6%9E%84%E5%BB%BAF8-App-part1%2F</url>
      <content type="text"><![CDATA[在第一部分，我们将介绍我们是如何计划的，在后面的部分，我们将分享示例代码，讨论多平台设计需要考虑的事情，分析应用的数据层，最后解释我们所选择的测试策略。 使用 React Native在 2015 年的 F8 大会，我们使用 React Native 开发了官方应用的 iOS 版，但 Android 版使用的是原生代码；在更早的大会上，我们在两个平台使用的都是原生代码。去年大会之后，React Native 发布了 Android 版本，这给我们提供了机会来削减应用的逻辑和 UI 代码。部分 Facebook 团队在使用 React Native 时发现达到了 85% 的代码共用。 React Native 在原型设计方面也有优势，它可以在你和 UI 设计师讨论的时候快速构建视觉组件原型，这些我们将在第二部分讨论。 所以，如果我们选择使用 React Native，还有什么需要考虑的？让我们先从内容开始。 选择一个数据层2014 和 15 年的 F8 应用都使用了Parse作为数据后端。因此，在我们计划开发 2016 年的应用时，使用 Parse 将允许我们重用现有的数据结构，以及能够快速开发开发。 选择 Parse 也有其它的原因 - 从大会准备到举办的期间，应用所展现的内容需要经常更新，并且内容更新应该像更新表格一样容易，而不需要工程师来协助。Parse 提供的 dashboard 能完美的满足这些需求。 由于以上原因，选择 Parse 作为后端顺理成章。不过，由于 Parse 宣布将停止服务，我们转而使用开源的 Parse Server 和 Parse Dashboard 来替代它。 由于 React Native 并不需要时刻与数据层保持紧密连接，比如 UI 和应用逻辑能使用模拟数据完成开发。这意味着我们可以仅以极少的代价替换整个数据层。比如在开发完 F8 应用后，我们能够非常容易的从 Parse 转移到开源的 Parse Server，我们将在第三部分进一步讨论。 React Native 应用的数据接入为了让 Parse 和 React Native 协同工作，我们已经有了 Parse + React Native package 来提供必需的绑定工具，不过这里有一个问题 - 考虑到会场 wi-fi 和连通性并不总是表现良好，F8 应用需要支持离线工作。因为 Parse + React 并不提供离线数据同步功能，我们只能自己开发。 这里还有另一个决定因素 - 团队大小。比如，提供类似功能的 Relay 更适合大型团队开发大规模应用，但 F8 应用的开发者只有一个人，以及少数其它人提供设计支持。这将极大影响你在开发应用中使用的数据接入方法。 那么 GraphQL 和 Relay 呢？虽然它们与 React Native 工作良好，但目前为止，Relay 不提供内建的离线使用，而 Parse 对 GraphQL 的支持并不完美。使用它们开发，我们需要构建 GraphQL 到 Parse 的 API，并且开发 Relay 的离线存储方法。 GraphQL 服务器的设置对于面临紧迫工期的个人来说也相对复杂。我需要开发应用并发布到应用商店，只能选择最简单并且最快的方式，除此之外我还能怎么做呢？ 由于以上原因，Redux 也是应用的一个最佳选择。Redux 提供了 Flux 架构的一个简单实现，对数据的存储和缓存提供更多控制，并最终让应用能从 Parse 进行单向同步。 对应用的存储部分，Redux 提供了功能性与易用性之间的平衡。在应用发布之后，我们重新梳理了这一部分，并且使用 Relay 和 GraphQL 实现了一遍，我们将在 Relay 和 GraphQL 附加部分讨论这些。 我们的开发技术栈将 React Native 作为我们的应用框架，以及 Redux 作为数据层，我们需要一些其它的支持技术和工具： 开源的 Parse Server 提供数据存储 - 运行在 Node.js 上。 我们使用了 Flow 来检查 React Native JavaScript 代码中的类型错误。 Jest framework 用来对复杂的函数进行单元测试。 使用 React Native Facebook SDK 来快速集成 Facebook 接入功能。 使用 OSX 平台的 Nuclide 编辑器，以及它内建的 React Native 支持。 我们还使用 Git 做版本管理，将开发的过程都存储到了 Github 上。 我们还使用了一些小的附加工具包，当我们在教程中碰到时会重点提到。 在你阅读系列教程的下一章节之前，我们推荐你先学习 React.js 的官方教程 - 特别是它的模块化组件概念以及 JSX 语法。然后阅读 React Native 的引导教程，它将展示将其用于移动应用开发的一些基础知识。]]></content>
    </entry>

    
  
  
</search>
